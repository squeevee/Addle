/**
 * Addle source code
 * @file
 * @copyright Copyright 2020 Eleanor Hawk
 * Modification and distribution permitted under the terms of the MIT License. 
 * See "LICENSE" for full details.
 */

#pragma once

#include <boost/parameter.hpp>
#include <boost/preprocessor.hpp>
#include <boost/callable_traits/return_type.hpp>
#include <boost/type_traits/is_complete.hpp>
#include <boost/type_traits/is_detected.hpp>
 
#include "factoryparamset.hpp"

// Same as original (Boost 1.75), but prepends `BOOST_DEDUCED_TYPENAME` to two 
// dependent names -- otherwise cannot be used in a class template. I should
// submit this as a change to Boost
#undef BOOST_PARAMETER_FUNCTION_FORWARD_OVERLOAD_0_Z
#define BOOST_PARAMETER_FUNCTION_FORWARD_OVERLOAD_0_Z(z, n, data)            \
    BOOST_PARAMETER_MEMBER_FUNCTION_STATIC(BOOST_PP_TUPLE_ELEM(4, 1, data))  \
    inline BOOST_DEDUCED_TYPENAME BOOST_PARAMETER_FUNCTION_RESULT_NAME(      \
        BOOST_PP_TUPLE_ELEM(4, 1, data)                                      \
      , BOOST_PP_TUPLE_ELEM(4, 3, data)                                      \
    )<                                                                       \
        BOOST_DEDUCED_TYPENAME ::boost::parameter::aux::argument_pack<       \
            BOOST_PARAMETER_FUNCTION_SPECIFICATION_NAME(                     \
                BOOST_PP_TUPLE_ELEM(4, 1, data)                              \
              , BOOST_PP_TUPLE_ELEM(4, 3, data)                              \
            )                                                                \
        >::type                                                              \
    >::type                                                                  \
    BOOST_PARAMETER_MEMBER_FUNCTION_NAME(BOOST_PP_TUPLE_ELEM(3, 0, data))()  \
    BOOST_PP_EXPR_IF(BOOST_PP_TUPLE_ELEM(4, 3, data), const)                 \
    {                                                                        \
        return BOOST_PP_EXPR_IF(BOOST_PP_TUPLE_ELEM(4, 2, data), this->)     \
        BOOST_PARAMETER_FUNCTION_IMPL_NAME(                                  \
            BOOST_PP_TUPLE_ELEM(4, 1, data)                                  \
          , BOOST_PP_TUPLE_ELEM(4, 3, data)                                  \
        )(                                                                   \
            BOOST_PARAMETER_FUNCTION_SPECIFICATION_NAME(                     \
                BOOST_PP_TUPLE_ELEM(4, 1, data)                              \
              , BOOST_PP_TUPLE_ELEM(4, 3, data)                              \
            )()()                                                            \
        );                                                                   \
    }
    
namespace Addle {
namespace Traits {
    
/**
 * If defined for an interface I, `factory_params<I>::type` is an alias for
 * a `FactoryParamSet` capable of forwarding all parameters from a valid call to
 * `IFactory<I>::make(...)`. 
 * 
 * Although multiple `FactoryParamSet` instantiations may be essentially 
 * equivalent, the one given by this trait is "canonical" and is the only one 
 * used in the factory / config stack for the respective interface. 
 * 
 * This means, e.g., that a non-template function, non-generic lambda, virtual
 * method or `std::function` can accept the parameter container for a particluar
 * interface.
 * 
 * Specializations are generated by ADDLE_DECL_FACTORY_PARAMETERS_IMPL, see below
 */
template<typename Interface> struct factory_params {};

} // namespace Traits

namespace config_detail {
    
template<
    class Interface, 
    typename F, 
    typename ResultType = decltype(
        std::declval<F>()(
            std::declval<typename Addle::Traits::factory_params<Interface>::type>()
        )
    )
>
struct factory_param_dispatcher {};

template<class Interface, typename F>
inline factory_param_dispatcher<Interface, F> 
    make_factory_param_dispatcher(F&& f)
{
    return factory_param_dispatcher<Interface, std::decay_t<F>>(std::forward<F>(f));
}

// A parameter in a Boost.Parameter enabled function cannot be explicitly typed
// as a reference or as a non-reference abstract type. To allow (references to)
// abstract types to be used as arguments, the parameters themselves are not
// strongly typed. But, to allow parameter deduction, we have this predicate
// that loosely emulates regular C++ argument matching.
template<typename Target>
struct basic_arg_predicate
{
    template<typename Source, typename...>
    struct fn 
        : boost::mp11::mp_any<
                std::is_convertible<
                    std::remove_reference_t<Source>*,
                    std::remove_reference_t<Target>*
                >,
                std::is_convertible<
                    std::remove_reference_t<Source>,
                    std::remove_reference_t<Target>
                >
            >
    {
        static_assert(
            boost::is_complete<Source>::value,
            "Incomplete types and references to incomplete types are not "
            "allowed as factory arguments. Make sure you've included any "
            "needed headers before calling IFactory<...>::make(...)"
            // If a work-around to this limitation is needed, note that 
            // pointers to incomplete types are allowed.
        );
    };
};

template<class Interface>
using factory_params_t = typename Traits::factory_params<Interface>::type;
    
template<class Interface>
using has_factory_params = boost::is_detected<factory_params_t, Interface>;

template<class Interface, typename... Args>
using _validate_factory_args_t = decltype(
        std::declval<factory_param_dispatcher<Interface, void(&)(...)>>()(std::declval<Args>()...)
    );

template<class Interface, typename... Args>
using is_makeable_with_params = boost::is_detected<_validate_factory_args_t, Interface, Args...>;

} // namespace config_detail

template<typename> class IFactory;
    
} // namespace Addle

#define ADDLE_FP_SIGENTRY_VALIDATE_required(x)
#define ADDLE_FP_SIGENTRY_VALIDATE_required_deduced(x)

#define ADDLE_FP_SIGENTRY_VALIDATE_optional(sig_entry)                      \
    static_assert(                                                          \
        !std::is_lvalue_reference<                                          \
            BOOST_PARAMETER_PARENTHESIZED_TYPE(                             \
                BOOST_PP_TUPLE_ELEM(2, sig_entry)                           \
            )                                                               \
        >::value                                                            \
        || std::is_const<std::remove_reference_t<                           \
            BOOST_PARAMETER_PARENTHESIZED_TYPE(                             \
                BOOST_PP_TUPLE_ELEM(2, sig_entry)                           \
            )                                                               \
        >>::value                                                           \
        || std::is_lvalue_reference<                                        \
            decltype(BOOST_PP_TUPLE_ELEM(3, sig_entry))                     \
        >::value,                                                           \
        "A mutable l-value reference may not be assigned an r-value "       \
        "as a default value"                                                \
    );
    
#define ADDLE_FP_SIGENTRY_VALIDATE_optional_deduced \
    ADDLE_FP_SIGENTRY_VALIDATE_optional

#define ADDLE_FP_SIGENTRY_VALIDATE(x, y, sig_entry)                         \
    static_assert(                                                          \
        !std::is_same<void*, void BOOST_PP_TUPLE_ELEM(2, sig_entry)>::value,\
        "`*` may not be given as a type for ADDLE_DECL_FACTORY_PARAMETERS"  \
    );                                                                      \
    BOOST_PP_CAT(                                                           \
        ADDLE_FP_SIGENTRY_VALIDATE_,                                        \
        BOOST_PP_TUPLE_ELEM(0, sig_entry)                                   \
    )(sig_entry)
    
#define ADDLE_FP_SIGENTRY_FACTORYPARAMINFO_QUALIFIER_optional()             \
    boost::mp11::mp_false

#define ADDLE_FP_SIGENTRY_FACTORYPARAMINFO_QUALIFIER_optional_deduced()     \
    boost::mp11::mp_false
    
#define ADDLE_FP_SIGENTRY_FACTORYPARAMINFO_QUALIFIER_required()             \
    boost::mp11::mp_true

#define ADDLE_FP_SIGENTRY_FACTORYPARAMINFO_QUALIFIER_required_deduced()     \
    boost::mp11::mp_true

#define ADDLE_FP_SIGENTRY_FACTORYPARAMINFO(x, tag_ns, sig_entry)            \
    BOOST_PARAMETER_PARENTHESIZED_TYPE((::Addle::config_detail              \
        ::FactoryParamInfo<                                                 \
        tag_ns::BOOST_PP_TUPLE_ELEM(1, sig_entry),                          \
        BOOST_PARAMETER_PARENTHESIZED_TYPE(                                 \
            BOOST_PP_TUPLE_ELEM(2, sig_entry)                               \
        ),                                                                  \
        BOOST_PP_CAT(                                                       \
            ADDLE_FP_SIGENTRY_FACTORYPARAMINFO_QUALIFIER_,                  \
            BOOST_PP_TUPLE_ELEM(0, sig_entry)                               \
        )()                                                                 \
    > ))

#define ADDLE_FP_SIGENTRY_INDIRECTTYPE(x, y, sig_entry)                     \
    (                                                                       \
        BOOST_PP_TUPLE_ELEM(0, sig_entry),                                  \
        BOOST_PP_TUPLE_ELEM(1, sig_entry),                                  \
        * (::Addle::config_detail::basic_arg_predicate<                     \
                BOOST_PARAMETER_PARENTHESIZED_TYPE(                         \
                    BOOST_PP_TUPLE_ELEM(2, sig_entry)                       \
                )                                                           \
        >),                                                                 \
        BOOST_PP_TUPLE_ELEM(3, sig_entry)                                   \
    )
    
#define ADDLE_FP_SIGENTRY_UNUSED(x, y, sig_entry)                           \
    (void)BOOST_PP_TUPLE_ELEM(1, sig_entry);

// 
// factory_param_dispatcher is the location of the Boost.Parameter-enabled
// function responsible for all the fancy Boost.Parameter features and
// assembling given arguments into the canonical parameter container type for
// the interface.
// 
// Because some of the available parameters may be references to temporary
// objects (e.g., the default values for optional parameters), the parameter
// container object must not outlive a call to this function -- hence it is a
// "dispatcher" and is responsible for calling `make_p` on the factory.
//
// Because of complications due to template and preprocessor generation, it's
// also necessary to explicitly specialize the `void` case of the dispatcher.
//
// It probably doesn't matter since the dispatcher is only ever created on the
// stack, but it should probably hold the function object in EBO-capable storage
#define ADDLE_DECL_FACTORY_PARAMETERS_IMPL(Interface, tag_ns, signature)    \
    template<>                                                              \
    struct Addle::Traits::factory_params<Interface> {                       \
        BOOST_PP_SEQ_FOR_EACH(                                              \
            ADDLE_FP_SIGENTRY_VALIDATE,                                     \
            ~,                                                              \
            signature                                                       \
        )                                                                   \
        using type = ::Addle::config_detail::FactoryParamSet<               \
                BOOST_PP_SEQ_ENUM(                                          \
                    BOOST_PP_SEQ_TRANSFORM(                                 \
                        ADDLE_FP_SIGENTRY_FACTORYPARAMINFO,                 \
                        tag_ns,                                             \
                        signature                                           \
                    )                                                       \
                )                                                           \
            >;                                                              \
    };                                                                      \
    template<typename F, typename ResultType_>                              \
    class Addle::config_detail                                              \
        ::factory_param_dispatcher<Interface, F, ResultType_>               \
    {                                                                       \
    public:                                                                 \
        using result_type = ResultType_;                                    \
        factory_param_dispatcher(const F& f)                                \
            : _f(f)                                                         \
        {                                                                   \
        }                                                                   \
        BOOST_PARAMETER_MEMBER_FUNCTION_AUX(                                \
                (result_type),                                              \
                operator(),                                                 \
                operator,                                                   \
                tag_ns,                                                     \
                1,                                                          \
                BOOST_PP_SEQ_TRANSFORM(                                     \
                    ADDLE_FP_SIGENTRY_INDIRECTTYPE,                         \
                    ~,                                                      \
                    signature                                               \
                )                                                           \
            )                                                               \
        {                                                                   \
            BOOST_PP_SEQ_FOR_EACH(ADDLE_FP_SIGENTRY_UNUSED, ~, signature)   \
            return _f(factory_params_t<Interface>(args));                   \
        }                                                                   \
    private:                                                                \
        F _f;                                                               \
    };                                                                      \
    template<typename F>                                                    \
    class Addle::config_detail                                              \
        ::factory_param_dispatcher<Interface, F, void>                      \
    {                                                                       \
    public:                                                                 \
        using result_type = void;                                           \
        factory_param_dispatcher(const F& f)                                \
            : _f(f)                                                         \
        {                                                                   \
        }                                                                   \
        BOOST_PARAMETER_MEMBER_FUNCTION_AUX(                                \
                (void),                                                     \
                operator(),                                                 \
                operator,                                                   \
                tag_ns,                                                     \
                1,                                                          \
                BOOST_PP_SEQ_TRANSFORM(                                     \
                    ADDLE_FP_SIGENTRY_INDIRECTTYPE,                         \
                    ~,                                                      \
                    signature                                               \
                )                                                           \
            )                                                               \
        {                                                                   \
            BOOST_PP_SEQ_FOR_EACH(ADDLE_FP_SIGENTRY_UNUSED, ~, signature)   \
            _f(factory_params_t<Interface>(args));                          \
        }                                                                   \
    private:                                                                \
        F _f;                                                               \
    };

#define ADDLE_DECL_FACTORY_PARAMETERS(Interface, signature)                 \
    ADDLE_DECL_FACTORY_PARAMETERS_IMPL(                                     \
        Interface,                                                          \
        Addle::BOOST_PP_CAT(aux_, Interface)::factory_param_tags,           \
        BOOST_PARAMETER_AUX_PP_FLATTEN(3, 2, 3, signature)                  \
    )
    
#define ADDLE_DECL_FACTORY_PARAMETERS_NS(Interface, tag_ns, signature)      \
    ADDLE_DECL_FACTORY_PARAMETERS_IMPL(                                     \
        Interface,                                                          \
        tag_ns,                      \
        BOOST_PARAMETER_AUX_PP_FLATTEN(3, 2, 3, signature)                  \
    )
    
// It'd be better for the keyword objects to be constexpr instead of just
// const reference -- I'm not sure why they aren't except maybe backwards 
// compatibility. Possibly write our own keyword class to do that, or add it 
// within a feature detection macro and submit the change to Boost.
//
// Also add BOOST_ATTRIBUTE_UNUSED or equivalent to the object declaration.
#define ADDLE_FACTORY_PARAMETER_NAME( name )                                \
    BOOST_PARAMETER_BASIC_NAME(                                             \
        factory_param_tags,                                                 \
        name,                                                               \
        forward_reference,                                                  \
        BOOST_PP_CAT(name, _)                                               \
    )

#define ADDLE_FACTORY_PARAMETER_ALIAS( Namespace, name )                    \
    namespace factory_param_tags {                                          \
        using Namespace::factory_param_tags::name;                          \
    }                                                                       \
    using Namespace::BOOST_PP_CAT(name, _);
    
namespace Addle::config_detail::generic_id_parameter {
    ADDLE_FACTORY_PARAMETER_NAME( id )
}
