/**
 * Addle source code
 * @file
 * @copyright Copyright 2020 Eleanor Hawk
 * Modification and distribution permitted under the terms of the MIT License. 
 * See "LICENSE" for full details.
 */

#pragma once

#include <boost/parameter.hpp>
#include <boost/preprocessor.hpp>
#include <boost/callable_traits/return_type.hpp>
#include <boost/type_traits/is_complete.hpp>
#include <boost/type_traits/is_detected.hpp>
 
#include "taggedvalueset.hpp"

// Same as original (Boost 1.75), but prepends `typename` to two dependent
// names -- otherwise cannot be used in a class template.
#undef BOOST_PARAMETER_FUNCTION_FORWARD_OVERLOAD_0_Z
#define BOOST_PARAMETER_FUNCTION_FORWARD_OVERLOAD_0_Z(z, n, data)            \
    BOOST_PARAMETER_MEMBER_FUNCTION_STATIC(BOOST_PP_TUPLE_ELEM(4, 1, data))  \
    inline typename BOOST_PARAMETER_FUNCTION_RESULT_NAME(                    \
        BOOST_PP_TUPLE_ELEM(4, 1, data)                                      \
      , BOOST_PP_TUPLE_ELEM(4, 3, data)                                      \
    )<                                                                       \
        typename ::boost::parameter::aux::argument_pack<                     \
            BOOST_PARAMETER_FUNCTION_SPECIFICATION_NAME(                     \
                BOOST_PP_TUPLE_ELEM(4, 1, data)                              \
              , BOOST_PP_TUPLE_ELEM(4, 3, data)                              \
            )                                                                \
        >::type                                                              \
    >::type                                                                  \
    BOOST_PARAMETER_MEMBER_FUNCTION_NAME(BOOST_PP_TUPLE_ELEM(3, 0, data))()  \
    BOOST_PP_EXPR_IF(BOOST_PP_TUPLE_ELEM(4, 3, data), const)                 \
    {                                                                        \
        return BOOST_PP_EXPR_IF(BOOST_PP_TUPLE_ELEM(4, 2, data), this->)     \
        BOOST_PARAMETER_FUNCTION_IMPL_NAME(                                  \
            BOOST_PP_TUPLE_ELEM(4, 1, data)                                  \
          , BOOST_PP_TUPLE_ELEM(4, 3, data)                                  \
        )(                                                                   \
            BOOST_PARAMETER_FUNCTION_SPECIFICATION_NAME(                     \
                BOOST_PP_TUPLE_ELEM(4, 1, data)                              \
              , BOOST_PP_TUPLE_ELEM(4, 3, data)                              \
            )()()                                                            \
        );                                                                   \
    }
    
namespace Addle {

    
namespace Traits {
    
/**
 * If defined for an interface I, `factory_parameters<I>::type` is an alias for
 * a `TaggedValueSet` capable of forwarding all parameters from a valid call to
 * `IFactory<I>::make(...)`. 
 * 
 * Although multiple `TaggedValueSet` instantiations may be essentially 
 * equivalent, the one given by this trait is "canonical" and is the only one 
 * used in the factory / config stack for the respective interface. 
 * 
 * This means, e.g., that a non-template function, non-generic lambda, virtual
 * method or `std::function` can accept the parameter container for a particluar
 * interface.
 * 
 * Specializations are generated by ADDLE_DECL_FACTORY_PARAMETERS_IMPL, see below
 */
template<typename Interface> struct factory_parameters {};

} // namespace Traits

namespace config_detail {
    
template<
    class Interface, 
    typename F, 
    typename ResultType = decltype(
        std::declval<F>()(
            std::declval<typename Addle::Traits::factory_parameters<Interface>::type>()
        )
    )
>
struct factory_parameter_dispatcher {};

template<class Interface, typename F>
inline factory_parameter_dispatcher<Interface, F> 
    make_factory_parameter_dispatcher(const F& f)
{
    return factory_parameter_dispatcher<Interface, F>(f);
}

// A parameter in a Boost.Parameter enabled function cannot be explicitly typed
// as a reference or as a non-reference abstract type. To allow (references to)
// abstract types to be used as arguments, the parameters themselves are not
// strongly typed. But, to allow parameter deduction, we have this predicate
// that loosely emulates regular C++ argument matching.
template<typename Target>
struct basic_arg_predicate
{
    template<typename Source, typename...>
    struct fn 
        : boost::mp11::mp_any<
                std::is_convertible<
                    std::remove_reference_t<Source>*,
                    std::remove_reference_t<Target>*
                >,
                std::is_convertible<
                    std::remove_reference_t<Source>,
                    std::remove_reference_t<Target>
                >
            >
    {
        static_assert(
            boost::is_complete<Source>::value,
            "Incomplete types and references to incomplete types are not "
            "allowed as factory arguments. Make sure you've included any "
            "needed headers before calling IFactory<...>::make(...)"
            // If a work-around to this limitation is needed, note that pointers 
            // to incomplete types are allowed.
        );
    };
};

template<class Interface>
using factory_params_t = typename Traits::factory_parameters<Interface>::type;
    
template<class Interface>
using has_factory_params = boost::is_detected<factory_params_t, Interface>;

} // namespace config_detail

template<typename> class IFactory;
    
} // namespace Addle

#define ADDLE_FP_SIGENTRY_VALIDATE_required(x)
#define ADDLE_FP_SIGENTRY_VALIDATE_required_deduced(x)

#define ADDLE_FP_SIGENTRY_VALIDATE_optional(sig_entry)                      \
    static_assert(                                                          \
        !std::is_lvalue_reference<                                          \
            BOOST_PARAMETER_PARENTHESIZED_TYPE(                             \
                BOOST_PP_TUPLE_ELEM(2, sig_entry)                           \
            )                                                               \
        >::value                                                            \
        || std::is_const<std::remove_reference_t<                           \
            BOOST_PARAMETER_PARENTHESIZED_TYPE(                             \
                BOOST_PP_TUPLE_ELEM(2, sig_entry)                           \
            )                                                               \
        >>::value                                                           \
        || std::is_lvalue_reference<                                        \
            decltype(BOOST_PP_TUPLE_ELEM(3, sig_entry))                     \
        >::value,                                                           \
        "A mutable l-value reference may not be assigned an r-value "       \
        "as a default value"                                                \
    );
    
#define ADDLE_FP_SIGENTRY_VALIDATE_optional_deduced \
    ADDLE_FP_SIGENTRY_VALIDATE_optional

#define ADDLE_FP_SIGENTRY_VALIDATE(x, y, sig_entry)                         \
    static_assert(                                                          \
        !std::is_same<void*, void BOOST_PP_TUPLE_ELEM(2, sig_entry)>::value,\
        "`*` may not be given as a type for ADDLE_DECL_FACTORY_PARAMETERS"  \
    );                                                                      \
    BOOST_PP_CAT(                                                           \
        ADDLE_FP_SIGENTRY_VALIDATE_,                                        \
        BOOST_PP_TUPLE_ELEM(0, sig_entry)                                   \
    )(sig_entry)

#define ADDLE_FP_SIGENTRY_TAGVALUEPAIR(x, tag_ns, sig_entry)                \
    BOOST_PARAMETER_PARENTHESIZED_TYPE(( TagValuePair<                      \
        tag_ns::BOOST_PP_TUPLE_ELEM(1, sig_entry),                          \
        BOOST_PARAMETER_PARENTHESIZED_TYPE(                                 \
            BOOST_PP_TUPLE_ELEM(2, sig_entry)                               \
        )                                                                   \
    > ))

#define ADDLE_FP_SIGENTRY_INDIRECTTYPE(x, y, sig_entry)                     \
    (                                                                       \
        BOOST_PP_TUPLE_ELEM(0, sig_entry),                                  \
        BOOST_PP_TUPLE_ELEM(1, sig_entry),                                  \
        * (::Addle::config_detail::basic_arg_predicate<                     \
                BOOST_PARAMETER_PARENTHESIZED_TYPE(                         \
                    BOOST_PP_TUPLE_ELEM(2, sig_entry)                       \
                )                                                           \
        >),                                                                 \
        BOOST_PP_TUPLE_ELEM(3, sig_entry)                                   \
    )
    
#define ADDLE_FP_SIGENTRY_UNUSED(x, y, sig_entry)                           \
    (void)BOOST_PP_TUPLE_ELEM(1, sig_entry);

// 
// factory_parameter_dispatcher is the location of the Boost.Parameter-enabled
// function responsible for all the fancy Boost.Parameter features and
// assembling given arguments into the canonical parameter container type for
// the interface.
// 
// Because some of the available parameters may be references to temporary
// objects (e.g., the default values for optional parameters), the parameter
// container object must not outlive a call to this function -- hence it is a
// "dispatcher" and is responsible for calling `make_p` on the factory.
//
// Because of complications due to template and preprocessor generation, it's
// also necessary to explicitly specialize the `void` case of the dispatcher.
#define ADDLE_DECL_FACTORY_PARAMETERS_IMPL(interface, tag_ns, signature)    \
    template<>                                                              \
    struct Addle::Traits::factory_parameters<interface> {                   \
        BOOST_PP_SEQ_FOR_EACH(                                              \
            ADDLE_FP_SIGENTRY_VALIDATE,                                     \
            ~,                                                              \
            signature                                                       \
        )                                                                   \
        using type = Addle::TaggedValueSet<                                 \
                BOOST_PP_SEQ_ENUM(                                          \
                    BOOST_PP_SEQ_TRANSFORM(                                 \
                        ADDLE_FP_SIGENTRY_TAGVALUEPAIR,                     \
                        tag_ns,                                             \
                        signature                                           \
                    )                                                       \
                )                                                           \
            >;                                                              \
    };                                                                      \
    template<typename F, typename ResultType_>                              \
    class Addle::config_detail                                              \
        ::factory_parameter_dispatcher<interface, F, ResultType_>           \
    {                                                                       \
    public:                                                                 \
        using param_container_type                                          \
            = typename Addle::Traits::factory_parameters<interface>::type;  \
        using result_type = ResultType_;                                    \
        factory_parameter_dispatcher(const F& f)                            \
            : _f(f)                                                         \
        {                                                                   \
        }                                                                   \
        BOOST_PARAMETER_MEMBER_FUNCTION_AUX(                                \
                (result_type),                                              \
                operator(),                                                 \
                operator,                                                   \
                tag_ns,                                                     \
                1,                                                          \
                BOOST_PP_SEQ_TRANSFORM(                                     \
                    ADDLE_FP_SIGENTRY_INDIRECTTYPE,                         \
                    ~,                                                      \
                    signature                                               \
                )                                                           \
            )                                                               \
        {                                                                   \
            BOOST_PP_SEQ_FOR_EACH(ADDLE_FP_SIGENTRY_UNUSED, ~, signature)   \
            return _f(param_container_type(args));                          \
        }                                                                   \
    private:                                                                \
        F _f;                                                               \
    };                                                                      \
    template<typename F>                                                    \
    class Addle::config_detail                                              \
        ::factory_parameter_dispatcher<interface, F, void>                  \
    {                                                                       \
    public:                                                                 \
        using param_container_type                                          \
            = typename Addle::Traits::factory_parameters<interface>::type;  \
        using result_type = void;                                           \
        factory_parameter_dispatcher(const F& f)                            \
            : _f(f)                                                         \
        {                                                                   \
        }                                                                   \
        BOOST_PARAMETER_MEMBER_FUNCTION_AUX(                                \
                (void),                                                     \
                operator(),                                                 \
                operator,                                                   \
                tag_ns,                                                     \
                1,                                                          \
                BOOST_PP_SEQ_TRANSFORM(                                     \
                    ADDLE_FP_SIGENTRY_INDIRECTTYPE,                         \
                    ~,                                                      \
                    signature                                               \
                )                                                           \
            )                                                               \
        {                                                                   \
            BOOST_PP_SEQ_FOR_EACH(ADDLE_FP_SIGENTRY_UNUSED, ~, signature)   \
            _f(param_container_type(args));                                 \
        }                                                                   \
    private:                                                                \
        F _f;                                                               \
    };

#define ADDLE_DECL_FACTORY_PARAMETERS(interface, signature)                 \
    ADDLE_DECL_FACTORY_PARAMETERS_IMPL(                                     \
        interface,                                                          \
        Addle::BOOST_PP_CAT(aux_, interface)::factory_param_tags,           \
        BOOST_PARAMETER_AUX_PP_FLATTEN(3, 2, 3, signature)                  \
    )
    
#define ADDLE_DECL_FACTORY_PARAMETERS_NS(interface, tag_ns, signature)      \
    ADDLE_DECL_FACTORY_PARAMETERS_IMPL(                                     \
        interface,                                                          \
        tag_ns,                      \
        BOOST_PARAMETER_AUX_PP_FLATTEN(3, 2, 3, signature)                  \
    )
    
#define ADDLE_FACTORY_PARAMETER_NAME( name )                                \
    BOOST_PARAMETER_BASIC_NAME(                                             \
        factory_param_tags,                                                 \
        name,                                                               \
        forward_reference,                                                  \
        BOOST_PP_CAT(name, _)                                               \
    )

#define ADDLE_FACTORY_PARAMETER_ALIAS( Namespace, name )                    \
    namespace factory_param_tags {                                          \
        using Namespace::factory_param_tags::name;                          \
    }                                                                       \
    using Namespace::BOOST_PP_CAT(name, _);
    
namespace Addle::config_detail::generic_id_parameter {
    ADDLE_FACTORY_PARAMETER_NAME( id )
}
